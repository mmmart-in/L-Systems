using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using System.Text;

public class BranchInfo
{
   public Vector3 scale;
   public Vector3 position;
   public Quaternion rotation;
   public float branchAngle;
}

public class LSystemEditor //: EditorWindow
{
    //Strings per generation, could be used to show "evolution" of the object
    private Dictionary<int, string> generationSubStrings = new Dictionary<int, string>();

    //Rules to expand the axiom
    private Dictionary<char, string> ruleSet = new Dictionary<char, string>();
    #region Inspector Values
    private float length;
    private float angle;
    private string axiom;
    private int generations;
    //the sentence generated by stringBuilder every generation
    //at this point, sentence is exposed for debugging only
    private string nextSentence;
    #endregion

    //Angles
    private float lastAngle = 0f;
    private float angleValue;

    //Debug
    private Text UIText;

    //Prefab and parent
    private GameObject branch;
    private GameObject treeParent;
    //private LineRenderer lr;


    private Stack<BranchInfo> branchStack = new Stack<BranchInfo>();
    Vector3 pointA, pointB;

    //[MenuItem("Window/L-System Editor")]

    private void InitRuleSet()
    {
        if (ruleSet.Count < 1)
        {
            //X → F+[[X]-X]-F[-FX]+X, (F → FF)
            ruleSet.Add('F', "FF");
            ruleSet.Add('-', "-");
            ruleSet.Add('+', "+");
            ruleSet.Add('X', " F+[[X]-X]-F[-FX]+X");
        }
    }
    /*static void Init()
    {
        GetWindow(typeof(LSystemEditor)).Show();
        
    }*/
   /* private void OnGUI()
    {
        length = EditorGUILayout.FloatField("Length", length);
        angle = EditorGUILayout.FloatField("Angle", angle);
        generations = EditorGUILayout.IntField("Generations", generations);
        axiom = EditorGUILayout.TextField("Axiom", axiom);
        nextSentence = EditorGUILayout.TextField("Sentence", nextSentence);
        branch = EditorGUILayout.ObjectField("Branch", branch, typeof(GameObject), true ) as GameObject;
       
        UIText = FindObjectOfType<Text>();

        if (GUILayout.Button("Generate"))
        {
            Generate();
        }
        if (GUILayout.Button("Reset"))
        {
            ResetText();
        }

    }*/
    private void ResetText()
    {
        UIText.text = "";
    }
    /*private void Generate()
    {
        InitRuleSet();
        treeParent = new GameObject();
        lastAngle = 0f;
        pointA = new Vector3(0, 0, 0); 

        //Always start with the axiom rather than sentence
        nextSentence = axiom;



        //Expand/age string before actually building the tree from it
        for (int i = 0; i < generations; i++)
        {
            StringBuilder sb = new StringBuilder();

            foreach (char c in nextSentence)
            {
                UIText.text += c;
                sb.Append(ruleSet.ContainsKey(c) ? ruleSet[c] : c.ToString());
            }
            nextSentence = sb.ToString();
        }

        //Build tree from the "final" sentence
        foreach (char c in nextSentence)
        {
            if (CalcAngle(c))
            {
                DrawLine(pointA);

                //Set next start position to this iterations end position
                pointA = pointB;
            }
        }

    }


    //randomisera färg
    //enumerator

    private bool CalcAngle(char c)
    {              
        switch (c)
        {
            case 'F':
                angleValue = 0;
                return true;
                
            case '-':
                lastAngle += -angle;
                break;

            case '+':
                lastAngle  += angle;
                break;
               
            case '[':
                branchStack.Push(new BranchInfo()
                {
                    position = pointA,
                    branchAngle = lastAngle
                }) ;
                break;

            case ']':
                {
                    BranchInfo bi = branchStack.Pop();
                    pointA = bi.position;
                    lastAngle = bi.branchAngle;             
                }
                break;
            case 'X':
                break;

            default:
                angleValue = 0;
                break;
        }
        return false;
    }
    private void DrawLine(Vector3 pointA)
    {
        float addedAngles = angleValue + lastAngle;

        Vector3 vectorLength = (Vector3.up * length);
        float theta = Mathf.Deg2Rad * addedAngles;
        float x = vectorLength.x * Mathf.Cos(theta) - vectorLength.y * Mathf.Sin(theta);
        float y = vectorLength.x * Mathf.Sin(theta) + vectorLength.y * Mathf.Cos(theta);

        //new Vector with pointA as starting point
        pointB = new Vector3(x + pointA.x, y + pointA.y, 0);

        //LR creation
        GameObject branchInstance = Instantiate(branch, treeParent.transform.transform);
        LineRenderer lineRenderer = branchInstance.GetComponent<LineRenderer>();
        branchInstance.transform.position = pointA;

        //LR positions
        lineRenderer.SetPosition(0, pointA);
        lineRenderer.SetPosition(1, pointB);

        lastAngle = addedAngles;

    }*/

     private void Generate()
    {
        InitRuleSet();
        treeParent = new GameObject();
        lastAngle = 0f;
        pointA = new Vector3(1, 1, 1);

        //Always start with the axiom rather than sentence
        nextSentence = axiom;



        //Expand/age string before actually building the tree from it
        for (int i = 0; i < generations; i++)
        {
            StringBuilder sb = new StringBuilder();

            foreach (char c in nextSentence)
            {
                UIText.text += c;
                sb.Append(ruleSet.ContainsKey(c) ? ruleSet[c] : c.ToString());
            }
            nextSentence = sb.ToString();
        }

        //Build tree from the "final" sentence
        foreach (char c in nextSentence)
        {
            if (CalcAngle(c))
            {
                DrawLine(pointA);

                //Set next start position to this iterations end position
                pointA = pointB;
            }
        }

    }


    //randomisera färg
    //enumerator

    private bool CalcAngle(char c)
    {
        switch (c)
        {
            case 'F':
               // initialPosition = transform.position;
                treeParent.transform.Translate(Vector3.up *  length);

                //GameObject fLine = currentString[(i + 1) % currentString.Length] == 'X' || currentString[(i + 3) % currentString.Length] == 'F' && currentString[(i + 4) % currentString.Length] == 'X' ? Instantiate(leaf) : Instantiate(branch);
                /*fLine.transform.SetParent(Tree.transform);
                fLine.GetComponent<LineRenderer>().SetPosition(0, initialPosition);
                fLine.GetComponent<LineRenderer>().SetPosition(1, transform.position);
                fLine.GetComponent<LineRenderer>().startWidth = width;
                fLine.GetComponent<LineRenderer>().endWidth = width;*/
                return true;
                break;

            case 'X':
                break;

            case '+':
                treeParent.transform.Rotate(Vector3.back * angle);
                break;

            case '-':
                treeParent.transform.Rotate(Vector3.forward * angle);
                break;

            case '*':
                treeParent.transform.Rotate(Vector3.up * 120);
                break;

            case '/':
                treeParent.transform.Rotate(Vector3.down * 120);
                break;

            case '[':
                branchStack.Push(new BranchInfo()
                {
                    position = pointA,
                    branchAngle = lastAngle,
                    rotation = treeParent.transform.rotation
                }) ;
                break;

            case ']':
                {
                    BranchInfo bi = branchStack.Pop();
                    pointA = bi.position;
                    lastAngle = bi.branchAngle;
                    treeParent.transform.rotation = bi.rotation;
                }
                break;
            default:
                angleValue = 0;
                break;
        }
        return false;
    }
    private void DrawLine(Vector3 pointA)
    {
        float addedAngles = angleValue + lastAngle;

        Vector3 vectorLength = (Vector3.up * length);
        float theta = Mathf.Deg2Rad * addedAngles;
        //Z-axis rotation
        float x = vectorLength.x * Mathf.Cos(theta) - vectorLength.y * Mathf.Sin(theta);
        float y = vectorLength.x * Mathf.Sin(theta) + vectorLength.y * Mathf.Cos(theta);
        //Y-Axis rotation facit
        float x2 = vectorLength.x * Mathf.Cos(theta) + vectorLength.z * Mathf.Sin(theta);
        float z2 = -vectorLength.x * Mathf.Sin(theta) + vectorLength.z * Mathf.Cos(theta);
        //new Vector with pointA as starting point
        Vector3 temp = new Vector3(x2 + pointA.x, vectorLength.y + pointA.y, pointA.z + z2);
        Vector3 temp2 = new Vector3(x + pointA.x, y + pointA.y, 0);
        Vector3 temp3 = new Vector3(x2 +  pointA.x,  pointA.y + y, pointA.z + z2);
        pointB = temp2;
        //Y-Axis rotation
        float x3 = pointB.x * Mathf.Cos(theta) + pointB.z * Mathf.Sin(theta);
        float z3 = -pointB.x * Mathf.Sin(theta) + pointB.z * Mathf.Cos(theta);
        //pointB = new Vector3(x3 , pointB.y , z3);
       
        Debug.Log("Magnitude: " +(pointB.magnitude - pointA.magnitude));
        //LR creation
        /*GameObject branchInstance = Instantiate(branch, treeParent.transform.transform);
        LineRenderer lineRenderer = branchInstance.GetComponent<LineRenderer>();
        branchInstance.transform.position = pointA;*/
       /* GameObject branchInstance = Instantiate(branch, treeParent.transform);
        branchInstance.transform.position = pointA;
        branchInstance.transform.rotation = treeParent.transform.rotation;*/

        //LR positions
        //lineRenderer.SetPosition(0, pointA);
        //lineRenderer.SetPosition(1, pointB);

        lastAngle = addedAngles;

    }
}
